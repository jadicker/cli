/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016-2021 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef CLI_COLORPROFILE_H_
#define CLI_COLORPROFILE_H_

#include "detail/rang.h"

#include <assert.h>
#include <optional>
#include <string>
#include <vector>
#include <unordered_map>

namespace cli
{

inline bool& Color() { static bool color; return color; }

inline void SetColor() { Color() = true; }
inline void SetNoColor() { Color() = false; }

enum BeforePrompt { beforePrompt };
enum AfterPrompt { afterPrompt };
enum BeforeInput { beforeInput };
enum AfterInput { afterInput };

enum Reset { reset };

template<typename ColorEnumT>
struct StyleHelper
{
    StyleHelper(ColorEnumT inColor, detail::rang::style inStyle = detail::rang::style::reset)
        : color(inColor)
        , style(inStyle)
    {
    }

    ColorEnumT color;
    detail::rang::style style = detail::rang::style::reset;
};

struct ColorHelper
{
    int m_r = 255;
    int m_g = 255;
    int m_b = 255;
    bool m_underline = false;
};

namespace Style
{
    using FGColor = StyleHelper<detail::rang::fg>;  
    
    inline FGColor Command() { return FGColor(detail::rang::fg::gray, detail::rang::style::italic); }
    inline FGColor Parameter() { return FGColor(detail::rang::fg::cyan); }
    inline FGColor ObjectId() { return FGColor(detail::rang::fg::green); }
    inline FGColor Object() { return FGColor(detail::rang::fg::cyan); }
    inline FGColor Mech() { return FGColor(detail::rang::fg::yellow); }

    inline FGColor Green() { return FGColor(detail::rang::fg::green); }
    inline FGColor Yellow() { return FGColor(detail::rang::fg::yellow); }
    inline FGColor Red() { return FGColor(detail::rang::fg::red); }

    inline std::string Reset() { return "\033[0m"; }

    extern std::string Color(unsigned char red, unsigned char green, unsigned char blue);

    inline std::string Color(const ColorHelper& helper)
    {
        return Color(helper.m_r, helper.m_g, helper.m_b);
    }

    extern std::string BGColor(unsigned char red, unsigned char green, unsigned char blue);

    class Error
    {
    public:
        Error(std::string&& message)
            : m_message(std::move(message))
        {}

        std::string m_message;
    };
}

inline std::ostream& operator<<(std::ostream& os, ColorHelper color)
{
    if (color.m_underline)
    {
        os << "\033[4m";
    }

    os << Style::Color(color.m_r, color.m_b, color.m_g);
    return os;
}

inline std::ostream& operator<<(std::ostream& os, BeforePrompt)
{
    if (Color())
    {
        os << ColorHelper{52, 144, 111, true};
    }
    return os;
}

inline std::ostream& operator<<(std::ostream& os, AfterPrompt)
{
    os << detail::rang::style::reset;
    return os;
}

inline std::ostream& operator<<(std::ostream& os, BeforeInput)
{
    if ( Color() ) { os << detail::rang::control::forceColor << detail::rang::fgB::gray; }
    return os;
}

inline std::ostream& operator<<(std::ostream& os, AfterInput)
{
    os << detail::rang::style::reset;
    return os;
}

template<typename ColorEnumT>
inline std::ostream& operator<<(std::ostream& os, StyleHelper<ColorEnumT> style)
{
    if (!Color())
        return os;

    if (style.color != ColorEnumT::reset)
    {
        os << detail::rang::control::forceColor << style.color;
    }

    if (style.style != detail::rang::style::reset)
    {
        os << style.style;
    }

    return os;
}

inline std::ostream& operator<<(std::ostream& os, Reset)
{
    os << detail::rang::style::reset;
    return os;
}

inline std::ostream& operator<<(std::ostream& os, const Style::Error& error)
{
    os << Style::Red() << error.m_message << reset;
    return os;
}

inline size_t GetCharLen(const char c)
{
    int cplen = 1;
    if ((c & 0xf8) == 0xf0)
    {
        return 4;
    }
    else if ((c & 0xf0) == 0xe0)
    {
        return 3;
    }
    else if ((c & 0xe0) == 0xc0)
    {
        return 2;
    }

    return 1;
}

// Returns amount of real chars to skip based on utf8 characters
inline size_t GetLength(std::string_view str, size_t chars)
{
    size_t outChars = 0;
    for (size_t i = 0; i < str.size();)
    {
        if (chars == 0)
        {
            return outChars;
        }

        size_t len = GetCharLen(str[i]);
        outChars += len;

        i += len;
        chars--;
    }
    return outChars;
}

// lines format is one line, then a line of chars that map to the color table to format them
using ColorTable = std::unordered_map<char, ColorHelper>;
extern std::string FormatColor(const ColorTable& colorTable, const std::vector<std::string>& lines);
extern std::string FormatColor(const ColorTable& colorTable,
                                const std::vector<std::string>& textLines,
                                const std::vector<std::string>& colorLines);
} // namespace cli

#endif // CLI_COLORPROFILE_H_


