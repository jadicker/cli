/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016-2021 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef CLI_DETAIL_TERMINAL_H_
#define CLI_DETAIL_TERMINAL_H_

#include <string>
#include <numeric>
#include "../colorprofile.h"
#include "inputdevice.h"
#include "autocomplete.h"

namespace cli
{
namespace detail
{

enum class Symbol
{
    nothing,
    command,
    up,
    down,
    tab,
    eof
};

class Terminal
{
  friend class ParamList;

  public:
    explicit Terminal(std::ostream &_out) : out(_out) {}

    void ResetInputLine() { m_position = m_promptSize; }

    void SetLine(const std::string &newLine)
    {
        out << beforeInput
            << std::string(GetInputPosition(), '\b') << newLine
            << afterInput << std::flush;

        // if newLine is shorter then currentLine, we have
        // to clear the rest of the string
        if (newLine.size() < m_currentLine.size())
        {
            out << std::string(m_currentLine.size() - newLine.size(), ' ');
            // and go back
            out << std::string(m_currentLine.size() - newLine.size(), '\b') << std::flush;
        }

        m_currentLine = newLine;
        m_position = m_currentLine.size() + m_promptSize;
    }

    void BackUpToPosition(size_t newPosition)
    {
        if (newPosition >= m_position)
        {
            return;
        }

        out << std::string(m_position - newPosition, '\b') << std::flush;
        m_position = newPosition;
    }

    // Doesn't support going down
    void GoBackToPosition(size_t posX, size_t posY)
    {
        assert(posY <= m_cursorY);
        Up(m_cursorY - posY);
        Advance(posX);
    }

    void CompleteLine()
    {
        const auto pos = static_cast<std::string::difference_type>(m_position - m_promptSize);

        out << beforeInput
            << std::string(m_currentLine.begin() + pos, m_currentLine.end())
            << afterInput << std::flush;
        m_position = m_promptSize + m_currentLine.size();
    }

    void SetCompletions(const std::vector<AutoCompletion>& completions, const std::string& cmdDesc);

    void InsertText(std::string str)
    {
        std::string& currentLine = m_cursorY == 0 ? m_currentLine : m_nextLines[m_cursorY - 1];
        size_t position = m_cursorY == 0 ? GetInputPosition() : m_position;
        
        const size_t remainingWidth = m_terminalWidth - m_position;
        size_t lineWidth = position + str.size();
        if (lineWidth > remainingWidth)
        {
            str.resize(remainingWidth - 4);
            str += " ..";
        }

        currentLine.insert(position, str.c_str());
        m_position += str.size();
        out << str << std::flush;
    }

    void TrimEnd(size_t toPosition, bool moveBack = true)
    {
        size_t oldSize = m_currentLine.size();
        if (oldSize <= toPosition)
        {
            return;
        }
        m_currentLine.erase(toPosition);
        m_position = toPosition;
        if (moveBack)
        {
            out << std::string(oldSize - toPosition, '\b') << std::flush;
        }
    }

    std::string GetLine() const { return m_currentLine; }

    std::pair<Symbol, std::string> Keypressed(std::pair<KeyType, char> k)
    {
        switch (k.first)
        {
            case KeyType::eof:
                return std::make_pair(Symbol::eof, std::string{});
                break;
            case KeyType::backspace:
            {
                if (GetInputPosition() == 0)
                    break;
                if (m_autoCompleteStart != std::string::npos && m_position <= m_autoCompleteStart)
                {
                    ClearAutoComplete();
                }

                --m_position;

                const auto pos = static_cast<std::string::difference_type>(GetInputPosition());
                // remove the char from buffer
                m_currentLine.erase(m_currentLine.begin() + pos);
                // go back to the previous char
                out << '\b';
                // output the rest of the line
                out << std::string(m_currentLine.begin() + pos, m_currentLine.end());
                // remove last char
                out << ' ';
                // go back to the original position
                out << std::string(m_currentLine.size() - GetInputPosition() + 1, '\b') << std::flush;

                break;
            }
            case KeyType::up:
                return std::make_pair(Symbol::up, std::string{});
                break;
            case KeyType::down:
                return std::make_pair(Symbol::down, std::string{});
                break;
            case KeyType::left:
                if (GetInputPosition() > 0)
                {
                    out << '\b' << std::flush;
                    --m_position;
                }
                break;
            case KeyType::right:
                if (GetInputPosition() < m_currentLine.size())
                {
                    out << beforeInput
                        << m_currentLine[GetInputPosition()]
                        << afterInput << std::flush;
                    ++m_position;
                }
                break;
            case KeyType::ret:
            {
                size_t lastValidPosition = GetInputPosition();
                if (lastValidPosition >= m_currentLine.size())
                {
                    lastValidPosition = m_currentLine.size() - 1;
                }

                if (!m_currentLine.empty() && !std::isspace(m_currentLine[lastValidPosition]))
                {
                    TryFinishAutoComplete();
                }

                out << "\r\n";
                auto cmd = m_currentLine;
                m_currentLine.clear();
                m_position = m_currentLine.size();

                return std::make_pair(Symbol::command, cmd);
            }
            break;
            case KeyType::ascii:
            {
                const char c = static_cast<char>(k.second);
                if (c == '\t')
                {
                    return std::make_pair(Symbol::tab, std::string());
                }
                else
                {
                    if (m_autoCompleteStart != std::string::npos)
                    {
                        const char autoCompleteChar = ' ';
                        if (m_position < m_autoCompleteStart)
                        {
                            ClearAutoComplete();
                        }
                        else if (c == autoCompleteChar)
                        {
                            if (TryFinishAutoComplete())
                            {
                                break;
                            }
                        }
                    }
                    
                    const auto pos = static_cast<std::string::difference_type>(GetInputPosition());

                    // output the new char:
                    out << beforeInput << c;
                    // and the rest of the string:
                    out << std::string(m_currentLine.begin() + pos, m_currentLine.end())
                        << afterInput;

                    // go back to the original position
                    out << std::string(m_currentLine.size() - GetInputPosition(), '\b') << std::flush;

                    // update the buffer and cursor position:
                    m_currentLine.insert(m_currentLine.begin() + pos, c);
                    ++m_position;
                }
                break;
            }
            case KeyType::canc:
            {
                if (GetInputPosition() == m_currentLine.size())
                    break;

                const auto pos = static_cast<std::string::difference_type>(GetInputPosition());

                // output the rest of the line
                out << std::string(m_currentLine.begin() + pos + 1, m_currentLine.end());
                // remove last char
                out << ' ';
                // go back to the original position
                out << std::string(m_currentLine.size() - GetInputPosition(), '\b') << std::flush;
                // remove the char from buffer
                m_currentLine.erase(m_currentLine.begin() + pos);
                break;
            }
            case KeyType::end:
            {
                CompleteLine();
                break;
            }
            case KeyType::home:
            {
                BackUpToPosition(m_promptSize);
                break;
            }
            case KeyType::ignored:
                // TODO
                break;
        }

        return std::make_pair(Symbol::nothing, std::string());
    }

    // Returns the parameter index, 0 for the command name
    size_t GetParamIndex(const std::string& line) const
    {
        return GetCurrentParamInfo(m_currentLine).index;
    }

    void SetLineStart(size_t start)
    {
        m_promptSize = start;
        if (m_position < m_promptSize)
        {
            m_position = m_promptSize;
        }
    }

    size_t GetLineCount() const
    {
        return m_nextLines.size() + 1;
    }

    size_t GetInputPosition() const
    {
        return m_position - m_promptSize;
    }

    void TestFill2Lines()
    {
        size_t start = m_promptSize + m_currentLine.size();
        out << std::string(m_terminalWidth - start, '=') << std::flush;
        out << std::string(m_terminalWidth, '+') << std::flush;
        out << std::string(m_terminalWidth * 2 - start, '\b') << std::flush;
        
        // Front of previous line
        Up(1);
        
        // Advance back to position
        Advance(m_promptSize + m_position);

        out << std::flush;
    }

  private:
    struct ParamInfo
    {
        size_t index = std::numeric_limits<size_t>::max();
        size_t startPos = std::numeric_limits<size_t>::max();
        size_t endPos = std::numeric_limits<size_t>::max();
    };

    ParamInfo GetCurrentParamInfo(const std::string& line) const
    {
        ParamInfo paramInfo;
        if (line.empty())
        {
            return paramInfo;
        }

        auto EndOfToken = [](const std::string& str, size_t i, bool onWhitespace) -> size_t
        {
            for (; i < str.size(); ++i)
            {
                if (static_cast<bool>(std::isspace(str[i])) != onWhitespace)
                {
                    return i;
                }
            }
            return i;
        };

        paramInfo.index = 0;

        size_t paramStart = 0;
        size_t paramEnd = 0;

        // Note: eats leading whitespace
        bool onWhitespace = std::isspace(line[0]);
        bool whitespaceToken = onWhitespace;
        //size_t oldStartPos = 0;
        for (size_t i = 1; i < line.size() && (whitespaceToken || i < GetInputPosition());)
        {
            size_t endOfToken = EndOfToken(line, i, onWhitespace);
            if (endOfToken > paramEnd)
            {
                whitespaceToken = onWhitespace;
            }

            paramStart = paramEnd + 1;
            paramEnd = endOfToken - 1;
            if (endOfToken >= line.size())
            {
                if (whitespaceToken)
                {
                    paramStart += 1;
                    paramEnd += 1;
                }

                paramInfo.startPos = paramStart + m_promptSize;
                paramInfo.endPos = paramEnd + m_promptSize;
                return paramInfo;
            }

            if (!onWhitespace)
            {
                // Cleared token and hit whitespace, indicating a possible new param
                ++paramInfo.index;
            }
            //else
            //{
            //    oldStartPos = endOfToken + 1;
            //}

            onWhitespace = !onWhitespace;
            i = endOfToken;
        }

        paramStart += m_promptSize;
        paramEnd += m_promptSize;

        if (whitespaceToken && paramEnd < m_promptSize + line.size())
        {
            // Detected a new parameter, index is already updated
            paramStart = paramEnd + 2;
            paramEnd = paramStart;
        }

        paramInfo.startPos = paramStart;
        paramInfo.endPos = paramEnd;

        return paramInfo;
    }

    // Move the cursor forward
    void Advance(size_t size)
    {
        if (size == 0) { return; }

        std::stringstream token;
        token << "\033[" << size << "C";
        out << token.str();

        m_position += size;
    }

    void Reverse(size_t size)
    {
        if (size == 0) { return; }
        if (size > m_position) { size = m_position; }

        out << std::string(size, '\b');
        m_position -= size;
    }

    void Up(size_t lines)
    {
        if (lines == 0 || m_cursorY == 0) { return; }

        std::stringstream token;
        token << "\033[" << lines << "F";
        out << token.str();

        // Moves to start of line
        m_position = 0;
        m_cursorY -= lines;
    }

    void Down(size_t lines)
    {
        if (lines == 0) { return; }

        std::stringstream token;
        token << "\033[" << lines << "E";
        out << token.str();

        // Moves to start of line
        m_position = 0;
        m_cursorY += lines;
    }

    // Wipes size characters ahead of current position and leaves the cursor/position be
    void ClearAhead()
    {
        if (m_currentLine.size() <= m_position)
        {
            return;
        }

        size_t size = m_currentLine.size() - m_position;
        m_currentLine.erase(m_position, size);
        out << std::string(size, ' ') << std::string(size, '\b') << std::flush;
    }

    void ClearBehind(size_t size)
    {
        if (size == 0) { return; }
        if (size > GetInputPosition()) { size = GetInputPosition(); }

        out << std::string(size, '\b') << std::string(size, ' ') << std::string(size, '\b');
        m_currentLine.erase(GetInputPosition() - size, size);
        m_position -= size;
    }

    void ClearAutoComplete()
    {
        if (m_autoCompleteStart == std::string::npos)
        {
            return;
        }

        size_t endCurrentToken = GetInputPosition();
        while (!std::isspace(m_currentLine[endCurrentToken]) && m_currentLine.size() > endCurrentToken + 1)
        {
            ++endCurrentToken;
        }

        size_t finalPosition = m_position;

        while (std::isspace(m_currentLine[endCurrentToken]) && m_currentLine.size() > endCurrentToken + 1)
        {
            ++endCurrentToken;
        }

        Advance(m_promptSize + endCurrentToken - finalPosition);
        ClearToCurrent();
        m_autoCompleteStart = std::string::npos;

        Reverse(m_position - finalPosition);
    }

    bool TryFinishAutoComplete()
    {
        if (m_autoCompleteStart == std::string::npos || 
            m_position >= m_currentLine.size() + m_promptSize)
        {
            return false;
        }

        ParamInfo paramInfo = GetCurrentParamInfo(m_currentLine);
        if (m_position < paramInfo.startPos || m_position > paramInfo.endPos)
        {
            return false;
        }

        ClearNextLines();

        // Re-print in regular text
        Reverse(m_position - paramInfo.startPos);
        out << beforeInput
            << std::string(m_currentLine.begin() + (paramInfo.startPos - m_promptSize),
                           m_currentLine.begin() + (paramInfo.endPos + 1 - m_promptSize))
            << afterInput << std::flush;
        m_position = paramInfo.endPos + 1;

        size_t endCurrentToken = GetInputPosition();
        while (!std::isspace(m_currentLine[endCurrentToken]) && m_currentLine.size() > endCurrentToken + 1)
        {
            ++endCurrentToken;
        }
        ++endCurrentToken;

        const size_t endCurrentTokenAbsolute = m_promptSize + endCurrentToken;
        if ((m_promptSize + m_currentLine.size()) == m_position)
        {
            InsertText(" ");
        }
        else
        {
            Advance(1);
        }

        //ClearToCurrent();
        return true;
    }

    // Resets the cursor to the input position on the input line
    void ResetCursor()
    {
        Up(m_cursorY);
        Advance(m_position);
    }

    struct SavePosition final
    {
        SavePosition(Terminal* terminal)
            : m_terminal(terminal)
            , m_position(terminal->m_position)
            , m_cursorY(terminal->m_cursorY)
        {}

        ~SavePosition()
        {
            m_terminal->GoBackToPosition(m_position, m_cursorY);
        }

        Terminal* m_terminal;
        size_t m_position;
        size_t m_cursorY;
    };

    void ClearNextLines()
    {
        size_t oldPosition = m_position;
        bool clearedLines = m_nextLines.size() > 0;
        while (m_nextLines.size() > 0)
        {
            assert(m_cursorY <= (GetLineCount() - 1));
            size_t dist = (GetLineCount() - 1) - m_cursorY;
            Down(dist);
            out << std::string(/*m_nextLines[m_cursorY - 1].size()*/m_terminalWidth, ' ');
            Up(dist);
            m_nextLines.pop_back();
        }

        // m_position stays constant this whole time
        if (clearedLines)
        {
            Advance(oldPosition);
        }
    }

    // Clears everything after current input
    void ClearToCurrent()
    {
        ClearNextLines();
        if (!m_currentLine.empty() && !std::isspace(m_currentLine.back()))
        {
            auto lastSpace = std::find_if(m_currentLine.rbegin(), m_currentLine.rend(),
                                          [](char c) { return std::isspace(c); });
            if (lastSpace != m_currentLine.rend())
            {
                auto dist = std::distance(m_currentLine.rbegin(), lastSpace);
                if (dist >= 1)
                {
                    Advance((m_promptSize + m_currentLine.size()) - m_position);
                    ClearBehind(dist);
                }
            }
        }
        
        out << std::flush;
    }

    void CreateLines(size_t count)
    {
        SavePosition save(this);
        for (size_t i = 0; i < count; ++i)
        {
            out << "\r\n";
        }
        m_cursorY += count;
    }

    void AddLine(const std::string& line)
    {
        Down(1);
        out << line << std::flush;
        m_nextLines.push_back(line);
        m_position = line.size();
    }

    std::string m_currentLine;
    // Suffix is the temporary data at the end of the current line
    //std::string m_currentSuffix;
    // All remaining lines are temporary
    std::vector<std::string> m_nextLines;

    size_t m_autoCompleteStart = std::string::npos;
    size_t m_position = 0; // next writing position in currentLine
    size_t m_cursorY = 0; // 0: current line
    size_t m_promptSize = 0;
    size_t m_terminalWidth = 120; // make an assumption for now
    std::ostream &out;
};

class ParamList
{
public:
    using Params = std::vector<AutoCompletion>;

    ParamList(const Params& params) : m_params(params) {}

    // Returns lines printed
    size_t Print(Terminal& t, size_t paramStartPos, size_t style)
    {
        if (m_params.empty())
        {
            // TODO: Show no valid/additional completions
            return 0;
        }

        if (m_params.size() == 1)
        {
            t.AddLine(std::string(paramStartPos, ' '));
            t.InsertText("^> ");
            t.InsertText(m_params[0].description);
            return 1;
        }

        if (style == 0)
        {
            // ^ [a b c d] going forward
            //size_t width = (t.m_terminalWidth - paramStartPos) + 2;

            t.AddLine(std::string(paramStartPos, ' '));
            t.InsertText("^ [");

            t.out << rang::fg::blue;

            std::string completionSuffix;
            for (size_t i = 1; i < m_params.size(); ++i)
            {
                completionSuffix += m_params[i].text;
                if (i != m_params.size() - 1)
                {
                    completionSuffix += "  ";
                }
            }

            t.InsertText(completionSuffix);

            t.out << rang::style::reset;

            t.InsertText("]");
        }
        else if (style == 1)
        {
            // prompt> cmd parm
            //  [.. b c d] ^ <desc text>
            // ^          ^ > subtract these from the width
            size_t width = paramStartPos - 3;

            size_t paramCount = 0;
            std::vector<std::string> paramList;
            size_t spaceSize = 1;
            size_t remainingSize = width - 2; // Subtract '[' and ']'
            // This much remaining room is needed to squeeze one last param in.  Includes the space
            constexpr size_t minFinalTokenWidth = 6;
            {
                // See how many we can fit with 1 space
                for (size_t i = 1; i < m_params.size(); ++i)
                {
                    const size_t size = m_params[i].text.size() + 
                        (paramCount > 1 ? spaceSize : 0);
                    if (remainingSize < size)
                    {
                        break;
                    }

                    ++paramCount;
                    remainingSize -= size;
                }

                for (size_t i = 0; i < paramCount; ++i)
                {
                    paramList.push_back(m_params[i + 1].text);
                }

                if (paramCount < m_params.size() &&
                    paramCount > 0 &&   // lastCertainParam is invalid with no params
                    remainingSize >= minFinalTokenWidth)
                {
                    // Cram in an abbreviated param, we have a param and room.  Leave room for a space.
                    std::string finalParam = m_params[paramCount].text;
                    finalParam.replace(minFinalTokenWidth - 3, 2, "..");
                    finalParam = finalParam.substr(0, minFinalTokenWidth - 1);

                    // Sneak in extra first param
                    remainingSize -= (finalParam.size() + spaceSize);
                    paramList.push_back(std::move(finalParam));
                }
                else if (paramCount > 0 && remainingSize > 0)
                {
                    // Fiddle with spacing instead, we can't fit anything else in
                    size_t oldSpaceSize = spaceSize;
                    spaceSize = oldSpaceSize + (remainingSize / paramCount);
                    if (spaceSize > oldSpaceSize)
                    {
                        remainingSize = remainingSize - ((paramCount - 1) * (spaceSize - oldSpaceSize));
                    }
                }
            }

            std::reverse(paramList.begin(), paramList.end());

            // Extra space at the start
            t.AddLine(std::string(remainingSize + 1, ' '));
            t.InsertText("[");
            t.out << rang::fg::blue;

            for (size_t i = 0; i < paramList.size(); ++i)
            {
                t.InsertText(paramList[i]);
                if (i != paramList.size() - 1)
                {
                    t.InsertText(std::string(spaceSize, ' '));
                }
            }
            t.out << rang::style::reset;
            t.InsertText("] ");

            t.InsertText("^> ");
            t.InsertText(m_params[0].description);
            return 1;
        }

        return 0;
    }

private:
    Params m_params;
};

void Terminal::SetCompletions(const std::vector<AutoCompletion>& completions, const std::string& cmdDesc)
{
    assert(!completions.empty());

    // TODO: Should probably clear remainder of command here
    ParamInfo paramInfo = GetCurrentParamInfo(m_currentLine);
    if (paramInfo.index == 0)
    {
        // TODO: This function doesn't handle commands yet
        return;
    }

    m_autoCompleteStart = paramInfo.startPos;

    ClearToCurrent();

    size_t oldPosition = m_position;

    // Uses 2 additional lines, make sure we have room
    CreateLines(2);

    out << rang::fg::yellow;
    InsertText(completions[0].text);
    out << rang::style::reset;

    // Clear the line
#if 0
    Down(1);
    Advance(m_promptSize + m_position);
#endif

    ParamList paramList(completions);
    size_t linesPrinted = paramList.Print(*this, oldPosition, 1);

    // Add description line
    AddLine(std::string(oldPosition, ' '));
    InsertText(cmdDesc);

    Up(1 + linesPrinted);
    Advance(oldPosition);

    out << std::flush;
}

} // namespace detail
} // namespace cli

#endif // CLI_DETAIL_TERMINAL_H_
