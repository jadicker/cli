/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016-2021 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef CLI_CLI_H
#define CLI_CLI_H

#include <string>
#include <vector>
#include <memory>
#include <functional>
#include <algorithm>
#include <cctype> // std::isspace
#include <type_traits>
#include "colorprofile.h"
#include "detail/history.h"
#include "detail/split.h"
#include "detail/fromstring.h"
#include "historystorage.h"
#include "volatilehistorystorage.h"
#include <iostream>
#include <utility>

#include "mechsimtypes.h"
#include "mechsimtostring.h"

class ConsoleTestRunner;

struct Utf8StringInfo
{
    size_t charCount = 0;
    size_t extraBytes = 0;	// Bytes used by utf8 extension
};

static Utf8StringInfo GetUtf8Info(const std::string& str)
{
    Utf8StringInfo info;
    bool onExtendedChar = false;

    const char* c = str.c_str();
    for (size_t i = 0; i < str.size(); i++)
    {
        if ((0x80 & str[i]) > 0)
        {
            if (onExtendedChar)
            {
                info.extraBytes++;
            }
            else
            {
                onExtendedChar = true;
                info.charCount++;
            }
            
            continue;
        }
        onExtendedChar = false;

        info.charCount++;
    }

    return info;
}

class OnScopeExit final
{
public:
    OnScopeExit(std::function<void()> func) : m_func(func)
    {}
    ~OnScopeExit()
    {
        m_func();
    }

private:
    std::function<void()> m_func;
};

namespace cli
{
    // ********************************************************************

    //template < typename T > struct TypeDesc { static const char* Name() { return ""; } };
    template <> struct TypeDesc< char > { static const char* Name() { return "<char>"; } };
    template <> struct TypeDesc< unsigned char > { static const char* Name() { return "<unsigned char>"; } };
    template <> struct TypeDesc< signed char > { static const char* Name() { return "<signed char>"; } };
    template <> struct TypeDesc< short > { static const char* Name() { return "<short>"; } };
    template <> struct TypeDesc< unsigned short > { static const char* Name() { return "<unsigned short>"; } };
    template <> struct TypeDesc< int > { static const char* Name() { return "<int>"; } };
    template <> struct TypeDesc< unsigned int > { static const char* Name() { return "<unsigned int>"; } };
    template <> struct TypeDesc< long > { static const char* Name() { return "<long>"; } };
    template <> struct TypeDesc< unsigned long > { static const char* Name() { return "<unsigned long>"; } };
    template <> struct TypeDesc< long long > { static const char* Name() { return "<long long>"; } };
    template <> struct TypeDesc< unsigned long long > { static const char* Name() { return "<unsigned long long>"; } };
    template <> struct TypeDesc< float > { static const char* Name() { return "<float>"; } };
    template <> struct TypeDesc< double > { static const char* Name() { return "<double>"; } };
    template <> struct TypeDesc< long double > { static const char* Name() { return "<long double>"; } };
    template <> struct TypeDesc< bool > { static const char* Name() { return "<bool>"; } };
    template <> struct TypeDesc< std::string > { static const char* Name() { return "<string>"; } };
    template <> struct TypeDesc< std::vector<std::string> > { static const char* Name() { return "<list of strings>"; } };
    
    template <> struct TypeDesc<FilteredObjParam<MechSim::Part, ObjFilters::MountableByController>> { static const char* Name() { return "Controllable"; } };

    template <typename T, typename Fn>
    struct TypeDesc<FilteredObjParam<T, Fn>>
    {
        static std::string Name()
        {
            std::stringstream str;
            str << Style::Object() << typeid(T).name() << reset;
            return str.str();
        }
    };

    static std::string Pad(const std::string& str, size_t count)
    {
        std::string out;
        out.reserve(count);
        for (size_t i = 0; i < count; ++i)
        {
            out += str;
        }
        return out;
    }

    static size_t get_n_chars_from_back_utf8(const std::string& str, size_t n)
    {
        const char* c = str.c_str();
        for (int i = static_cast<int>(str.size()) - 1; i >= 0; --i)
        {
            if ((0x80 & str[i]) > 0)
            {
                continue;
            }

            --n;
            if (n == 0)
            {
                return i;
            }
        }

        return 0;
    }

    // ********************************************************************

    // this class provides a global output stream
    class OutStream : public std::basic_ostream<char>, public std::streambuf
    {
    public:
        OutStream() : std::basic_ostream<char>(this)
        {
        }

        // std::streambuf overrides
        std::streamsize xsputn(const char* s, std::streamsize n) override
        {
            for (auto os: ostreams)
                os->rdbuf()->sputn(s, n);
            return n;
        }
        int overflow(int c) override
        {
            for (auto os: ostreams)
                *os << static_cast<char>(c);
            return c;
        }            

        void Register(std::ostream& o)
        {
            ostreams.push_back(&o);
        }
        void UnRegister(std::ostream& o)
        {
            ostreams.erase(std::remove(ostreams.begin(), ostreams.end(), &o), ostreams.end());
        }

    private:

        std::vector<std::ostream*> ostreams;
    };
    
    // forward declarations
    class Command;
    class CliSession;

    class Cli
    {
        friend class ConsoleTestRunner;

    public:
        ~Cli() = default;
        // disable value semantics
        Cli(const Cli&) = delete;
        Cli& operator = (const Cli&) = delete;
        // enable move semantics
        Cli(Cli&&) = default;
        Cli& operator = (Cli&&) = default;

        /**
         * @brief Construct a new Cli object having a given root menu that contains the first level commands available.
         * 
         * @param _rootMenu is the @c Menu containing the first level commands available to the user.
         * @param historyStorage is the policy for the storage of the cli commands history. You must pass an istance of
         * a class derived from @c HistoryStorage. The library provides these policies:
         *   - @c VolatileHistoryStorage
         *   - @c FileHistoryStorage it's a persistent history. I.e., the command history is preserved after your application
         *     is restarted.
         * 
         * However, you can develop your own, just derive a class from @c HistoryStorage .
         */
        Cli(std::unique_ptr<HistoryStorage> historyStorage = std::make_unique<VolatileHistoryStorage>()) :
            globalHistoryStorage(std::move(historyStorage)),
            exitAction{}
        {
        }

        void SetRootMenu(std::shared_ptr<Command> inRootMenu)
        {
            rootMenu = inRootMenu;
        }

        /**
         * @brief Add a global exit action that is called every time a session (local or remote) gets the "exit" command.
         * 
         * @param action the function to be called when a session exits, taking a @c std::ostream& parameter to write on that session console.
         */
        void ExitAction(const std::function< void(std::ostream&)>& action) { exitAction = action; }

        /**
         * @brief Add an handler that will be called when a @c std::exception (or derived) is thrown inside a command handler.
         * If an exception handler is not set, the exception will be logget on the session output stream.
         * 
         * @param handler the function to be called when an exception is thrown, taking a @c std::ostream& parameter to write on that session console
         * and the exception thrown.
         */
        void StdExceptionHandler(const std::function< void(std::ostream&, const std::string& cmd, const std::exception&) >& handler)
        {
            exceptionHandler = handler;
        }

        /**
         * @brief Get a global out stream object that can be used to print on every session currently connected (local and remote)
         * 
         * @return OutStream& the reference to the global out stream writing on every session console. 
         */
        static OutStream& cout()
        {
            return *CoutPtr();
        }

    private:
        friend class CliSession;

        static std::shared_ptr<OutStream> CoutPtr()
        {
            static std::shared_ptr<OutStream> s = std::make_shared<OutStream>();
            return s;
        }

        Command* RootMenu() { return rootMenu.get(); }

        void ExitAction( std::ostream& out )
        {
            if ( exitAction )
                exitAction( out );
        }

        void StdExceptionHandler(std::ostream& out, const std::string& cmd, const std::exception& e)
        {
            if (exceptionHandler)
                exceptionHandler(out, cmd, e);
            else
                out << e.what() << '\n';
        }

        void StoreCommands(const std::vector<std::string>& cmds)
        {
            globalHistoryStorage->Store(cmds);
        }

        std::vector<std::string> GetCommands() const
        {
            return globalHistoryStorage->Commands();
        }

    private:
        std::unique_ptr<HistoryStorage> globalHistoryStorage;
        std::shared_ptr<Command> rootMenu;
        std::function<void(std::ostream&)> exitAction;
        std::function<void(std::ostream&, const std::string& cmd, const std::exception& )> exceptionHandler;
    };

    // ********************************************************************


    class CmdHandler;

    class Command
    {
    public:
        enum class ValidationResult
        {
            NoMatch,
            Match,
            Invalid
        };

        using CleanupFn = std::function<void()>;

        Command() : enabled(true), parent(nullptr), description(), cmds(std::make_shared<Cmds>()) {}
        explicit Command(std::string _name) : name(std::move(_name)), enabled(true), parent(nullptr), description(), cmds(std::make_shared<Cmds>()) {}
        explicit Command(std::string _name, std::string _desc) : name(std::move(_name)), enabled(true), parent(nullptr), description(std::move(_desc)), cmds(std::make_shared<Cmds>()) {}
        virtual ~Command() noexcept = default;

        // disable copy and move semantics
        Command(const Command&) = delete;
        Command(Command&&) = delete;
        Command& operator=(const Command&) = delete;
        Command& operator=(Command&&) = delete;

        virtual void Enable() { enabled = true; }
        virtual void Disable() { enabled = false; }

        bool HasChildren() const { return cmds && !cmds->empty(); }

        virtual void Cleanup() {}

        void AddCommands(const Command& other)
        {
            assert(other.cmds);
            const auto& otherCmds = *other.cmds;
            std::copy(otherCmds.begin(), otherCmds.end(), cmds->end());
        }

        void TransferRootCommands(Command& other)
        {
            assert(other.cmds && cmds);
            auto& otherCmds = *other.cmds;
            for (auto iter = otherCmds.begin(); iter != otherCmds.end(); ++iter)
            {
                if (dynamic_cast<const Command*>(iter->get()))
                {
                    cmds->push_back(*iter);
                    //iter = otherCmds.erase(iter);
                }
            }
        }

        virtual ValidationResult Validate(const std::vector<std::string>& cmdLine)
        {
            // Always match/follow menus
            return ValidationResult::Match;
        }

        virtual bool Exec(const std::vector<std::string>& cmdLine, CliSession& session);

        virtual void ResetAutoComplete() { }

        void ResetAutoCompleteRecursive()
        {
            ResetAutoComplete();
            for (auto& cmd : *cmds)
            {
                cmd->ResetAutoCompleteRecursive();
            }
        }

        enum class ScanResultAction
        {
            NoneFound,
            Executed,
            BadParams
        };

        using ScanResult = std::pair<std::vector<Command*>, ScanResultAction>;
        ScanResult ScanCmds(const std::vector<std::string>& cmdLine, CliSession& session);

        std::string Prompt() const
        {
            return Name();
        }

        Command* GetParent() const { return parent; }

        void MainHelp(std::ostream& out)
        {
            if (!IsEnabled()) return;
            for (const auto& cmd : *cmds)
                cmd->Help(out);
        }

        virtual void Help(std::ostream& out) const
        {
            if (!IsEnabled()) return;
            out << " - " << Name() << "\n\t" << description << "\n";
        }

        AutoCompleter::Completions GetChildCommandCompletions(const std::string& prefix)
        {
            if (!enabled) { return {}; }

            AutoCompleter::Completions completions;
            for (auto& cmd : *cmds)
            {
                if (cmd->Name().find(prefix) == 0)
                {
                    completions.push_back({ cmd->Name(), cmd->Description() });
                }
            }
            return completions;
        }

        struct CommandParams
        {
            std::reference_wrapper<Command> m_command;
            size_t m_paramsFound;

            // TODO: Pack parameter info into here that can be used to describe them further.
            // Maybe instead of having ParamAutoComplete template specializations as they exist today,
            // there should be objects that get constructed in the specialization case but otherwise can
            // be used here.  Something like "ParameterDescription"?  Then they can overload operator<<
            // for printing and have whatever CONCRETE data is needed to pack into a struct like this one
            // and remain understandable plus allow for traditional use of containers to pass around
            // rather than variadic templates.
        };

        std::vector<CommandParams> GetCommands(std::vector<std::string> params, size_t currentParam = 0) const
        {
            size_t param = 0;
            for (auto& cmd : *cmds)
            {
                auto cmdResults = cmd->GetCommandsImpl(params, param);
                if (!cmdResults.empty())
                {
                    return cmdResults;
                }
            }

            return {};
        }

        std::vector<CommandParams> GetCommandsImpl(const std::vector<std::string>& params,
            const size_t currentParam) const
        {
            size_t paramCount = MatchCommand(params, currentParam);
            if (paramCount == 0)
            {
                return {};
            }

            std::vector<CommandParams> commands;
            commands.push_back({ *const_cast<Command*>(this), std::min(GetParamCount(), paramCount) });

            size_t nextParam = currentParam + paramCount;
            // If we have enough paramaters and still have more param input left, keep going
            if (paramCount == GetParamCount() && nextParam < params.size() && cmds)
            {
                // See if there are child commands
                if (!cmds->empty())
                {
                    for (auto& cmd : *cmds)
                    {
                        auto results = cmd->GetCommandsImpl(params, nextParam);
                        if (!results.empty())
                        {
                            commands.insert(commands.end(), results.begin(), results.end());
                            // Command names should be unique
                            break;
                        }
                    }
                }
            }

            return commands;
        }

        std::vector<CommandParams> GetCurrentCommands(const std::string& commandLine) const
        {
            std::vector<std::string> params;
            detail::split(params, commandLine);

            return GetCommands(params, 0);
        }

        // Returns true if param is this command
        bool MatchCommandName(const std::string& param) const
        {
            if (!enabled) { return false; }
            return Name() == param;
        }

        // Returns how many parameters to eat, returns 0 if there is no match
        size_t MatchCommand(const std::vector<std::string>& params, size_t commandPosition = 0) const
        {
            if (!enabled) { return 0; }

            if (params.empty() || !MatchCommandName(params[commandPosition]))
            {
                return 0;
            }

            // We have some number of params, may be incomplete
            size_t i;
            for (i = 0; i < GetParamCount() - 1; ++i)
            {
                auto param = i + 1 + commandPosition;
                if (param >= params.size())
                {
                    break;
                }

                if (!ValidateParam(params[param], i))
                {
                    return i - 1;
                }
            }

            // Include param name
            return i + 1;
        }

        // Returns true if this command starts with param
        bool StartsWith(const std::string& param) const
        {
            if (!enabled) { return {}; }
            if (param.empty())
            {
                // If we have nothing, then say an empty string matches
                return true;
            }
            return param.find(Name()) == 0;
        }

        virtual AutoCompleter::Completions GetParamCompletion(const std::string& paramStr,
            const size_t param)
        {
            // On a pure menu, complete for our children, but can _only_ complete our single child param
            assert(param == 0);

            AutoCompleter::Completions results;
            for (auto& cmd : *cmds)
            {
                if (paramStr.empty() || cmd->StartsWith(paramStr))
                {
                    results.push_back({ cmd->Name(), cmd->Description() });
                }
            }

            return results;
        }

        template <typename F>
        CmdHandler Insert(const std::string& cmdName, F f, const std::string& help = "")
        {
            // dispatch to private Insert methods
            return Insert(cmdName, help, {}, f, &F::operator());
        }

        template <typename F>
        CmdHandler Insert(const std::string& cmdName, const std::vector<std::string>& parDesc, F f, const std::string& help = "")
        {
            // dispatch to private Insert methods
            return Insert(cmdName, help, parDesc, f, &F::operator());
        }

        template <typename F>
        CmdHandler Insert(const std::string& cmdName, const std::vector<std::string>& parDesc, F f, CleanupFn cleanupFunc, const std::string& help = "")
        {
            // dispatch to private Insert methods
            return Insert(cmdName, help, parDesc, f, cleanupFunc, &F::operator());
        }

        CmdHandler Insert(std::unique_ptr<Command>&& cmd);

        CmdHandler Insert(std::string&& menuName);

        const std::string& Name() const { return name; }
        const std::string& Description() const { return description; }

        const std::string GetPromptDisplay() const
        {
            if (m_displayFunc)
            {
                return (*m_displayFunc)();
            }
            return name;
        }

        // Includes this name
        virtual size_t GetParamCount() const { return 1; }
        virtual bool ValidateParam(const std::string& param, const size_t paramIndex) const { return false; }

        size_t m_commandAutoCompleteIndex = 0;

        const Command* GetCommand(const std::string& name) const
        {
            for (const auto& cmd : *cmds)
            {
                if (cmd->Name() == name)
                {
                    return cmd.get();
                }
            }
            return nullptr;
        }

        using PromptDisplayFn = std::function<std::string()>;
        void SetDisplayFunc(PromptDisplayFn displayFunc) { m_displayFunc = displayFunc; }

    protected:
        bool IsEnabled() const { return enabled; }

        const std::string description;

    private:
        std::optional<PromptDisplayFn> m_displayFunc;
        const std::string name;
        bool enabled;

        template <typename F, typename R, typename ... Args>
        CmdHandler Insert(const std::string& name, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, Args...) const);

        template <typename F, typename R, typename ... Args>
        CmdHandler Insert(const std::string& cmdName, const std::string& help, const std::vector<std::string>& parDesc, F& f, CleanupFn cleanupFunc, R(F::*)(std::ostream& out, Args...) const);

        template <typename F, typename R>
        CmdHandler Insert(const std::string& name, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, const std::vector<std::string>&) const);

        template <typename F, typename R>
        CmdHandler Insert(const std::string& name, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, std::vector<std::string>) const);

        CmdHandler Insert(const std::string& name, const std::string& help);

        Command* parent{ nullptr };
        
        // using shared_ptr instead of unique_ptr to get a weak_ptr
        // for the CmdHandler::Descriptor
        using Cmds = std::vector<std::shared_ptr<Command>>;
        std::shared_ptr<Cmds> cmds;
    };

    // ********************************************************************

    class CliSession
    {
        friend class ConsoleTestRunner;

    public:
        CliSession(Cli& _cli, std::ostream& _out, std::size_t historySize = 100);
        virtual ~CliSession() noexcept { coutPtr->UnRegister(out); }

        // disable value semantics
        CliSession(const CliSession&) = delete;
        CliSession& operator = (const CliSession&) = delete;
        // disable move semantics
        CliSession(CliSession&&) = delete;
        CliSession& operator = (CliSession&&) = delete;

        void SetSilent(bool silent)
        {
            m_silent = silent;
        }

        bool Feed(const std::string& cmd,
            bool dontSaveCommand = false,
            bool printCmd = false,
            bool silentOutput = false);

        void RunProgram(const std::string& name, const std::vector<std::string>& program);

        void Prompt()
        {
            SetPromptSize(PromptImpl());
        }

        void SetRootMenu(std::shared_ptr<Command> inRootMenu)
        {
            //currentGlobalScopeMenu.reset(new Command(""));
            //currentGlobalScopeMenu->TransferRootCommands(*inRootMenu);
            cli.SetRootMenu(inRootMenu);

            m_current = inRootMenu.get();
            m_rootMenu = m_current;
        }

        void Current(Command* menu)
        {
            if (m_testingExecution)
            {
                return;
            }

            m_menuParamIndex = 0;
            m_current = menu;
        }

        void SetTop()
        {
            m_top = m_current;
        }

        void Pop();

        std::ostream& OutStream();

        void Help() const;

        void Exit();

        void ExitAction(const std::function<void(std::ostream&)>& action)
        {
            exitAction = action;
        }

        void ShowHistory() const { history.Show(out); }

        std::string PreviousCmd(const std::string& line)
        {
            return history.Previous(line);
        }

        std::string NextCmd()
        {
            return history.Next();
        }

        const Command* GetCurrentCommand(const std::string& line) const;

        detail::AutoCompletion GetCurrentCommandCompletion(const std::string& line) const;

        struct CompletionResults
        {
            Command* m_command;
            size_t m_completionParamIndex;
            AutoCompleter::Completions m_completions;
        };
        CompletionResults GetCompletions(std::string currentLine, size_t param);

    private:
        virtual void SetPromptSize(size_t size) {}
        size_t PromptImpl();

        CompletionResults GetCompletionsImpl(Command* command,
            std::string currentLine,
            size_t param,
            const bool recursive = true);

        Cli& cli;
        std::shared_ptr<cli::OutStream> coutPtr;
        Command* m_current = nullptr;

        // Marker that can be set, used for popping scopes
        Command* m_top = nullptr;
        
        // Param index to use for command matching (rather than param matching)
        AutoCompleter::Completions m_previousCompletions;
        size_t m_menuParamIndex = 0;

        // Globals attached to current
        std::unique_ptr<Command> currentGlobalScopeMenu;
        // Globals attached to the CLI
        std::unique_ptr<Command> globalScopeMenu;
        Command* m_rootMenu;
        const Command* m_exitCommand = nullptr;
        std::ostream& out;
        std::ofstream m_nullOut;
        std::function< void(std::ostream&)> exitAction = []( std::ostream& ){};
        detail::History history;
        bool exit{ false }; // to prevent the prompt after exit command
        bool m_silent = false;
        bool m_testingExecution = false;
    };

    // ********************************************************************

    class CmdHandler
    {
    public:
        using CmdVec = std::vector<std::shared_ptr<Command>>;
        CmdHandler() : descriptor(std::make_shared<Descriptor>()) {}
        CmdHandler(std::weak_ptr<Command> c, std::weak_ptr<CmdVec> v) :
            descriptor(std::make_shared<Descriptor>(c, v))
        {}
        void Enable() { if (descriptor) descriptor->Enable(); }
        void Disable() { if (descriptor) descriptor->Disable(); }
        void Remove() { if (descriptor) descriptor->Remove(); }

        Command* operator->()
        {
            if (auto c = descriptor->cmd.lock())
                return c.get();

            return nullptr;
        }
    private:
        struct Descriptor
        {
            Descriptor() = default;
            Descriptor(std::weak_ptr<Command> c, std::weak_ptr<CmdVec> v) :
                cmd(std::move(c)), cmds(std::move(v))
            {}
            void Enable()
            {
                if (auto c = cmd.lock())
                    c->Enable();
            }
            void Disable()
            {
                if(auto c = cmd.lock())
                    c->Disable();
            }
            void Remove()
            {
                auto scmd = cmd.lock();
                auto scmds = cmds.lock();
                if (scmd && scmds)
                {
                    auto i = std::find_if(
                        scmds->begin(),
                        scmds->end(),
                        [&](const auto& c){ return c.get() == scmd.get(); }
                    );
                    if (i != scmds->end())
                        scmds->erase(i);
                }
            }
            std::weak_ptr<Command> cmd;
            std::weak_ptr<CmdVec> cmds;
        };
        std::shared_ptr<Descriptor> descriptor;
    };

    // ********************************************************************
    template<typename Target, typename ListHead, typename... ListTails>
    constexpr size_t getTypeIndexInTemplateList()
    {
        if constexpr (std::is_same<Target, ListHead>::value)
            return 0;
        else
            return 1 + getTypeIndexInTemplateList<Target, ListTails...>();
    }

    template <typename ... Args>
    struct Select;

    template <typename P, typename ... Args>
    struct Select<P, Args...>
    {
        template <typename F, typename InputIt>
        static bool Exec(std::ostream& out, const F& f, InputIt first, InputIt last,
            const std::vector<std::string>& parmDescs, size_t i)
        {
            assert( first != last );
            assert( std::distance(first, last) == 1+sizeof...(Args) );
            
            using UnqualifiedP = typename std::decay<P>::type;
            P p = detail::FromString<UnqualifiedP>::get(out, parmDescs[i], *first);
            
            auto g = [&](auto ... pars){ f(p, pars...); };
            return Select<Args...>::Exec(out, g, std::next(first), last, parmDescs, i + 1);
        }
    };

    // Zero or more template params - that is, zero
    template <typename ...Args>
    class ParamUtil
    {
    public:
        template <template <typename T> class Action>
        static auto CallWith(size_t i, const std::string& token)
        {
            return Action<void>::Get(token);
        }
    };

    // One or more template params
    template <typename ArgCar, typename ...ArgCdr>
    class ParamUtil<ArgCar, ArgCdr...>
    {
    public:
        // token is the current command line token
        template <template <typename T> class Action>
        static auto CallWith(size_t i, const std::string& token)
        {
            if (i > 0)
            {
                return ParamUtil<ArgCdr...>::CallWith<Action>(i - 1, token);
            }

            return Action<std::decay_t<ArgCar>>::Get(token);
        }
    };

    template <typename P, typename ... Args>
    struct Select<ObjParam<P>, Args...>
    {
        template <typename F, typename InputIt>
        static bool Exec(std::ostream& out, const F& f, InputIt first, InputIt last,
            const std::vector<std::string>& parmDescs, size_t i)
        {
            assert(first != last);
            assert(std::distance(first, last) == 1 + sizeof...(Args));
            ObjParam<P> objParam;
            if (!objParam.Create(out, parmDescs[i], *first))
            {
                return false;
            }

            auto g = [&](auto ... pars) { f(objParam, pars...); };
            return Select<Args...>::Exec(out, g, std::next(first), last, parmDescs, i + 1);
        }
    };

    template <>
    struct Select<>
    {
        template <typename F, typename InputIt>
        static bool Exec(std::ostream& out, const F& f, InputIt first, InputIt last,
            const std::vector<std::string>& parmDescs, size_t i)
        {
            // silence the unused warning in release mode when assert is disabled
            static_cast<void>(first);
            static_cast<void>(last);

            assert(first == last);
            
            f();
            return true;
        }
    };

    template <typename ... Args>
    struct PrintDesc;

    template <typename P, typename ... Args>
    struct PrintDesc<P, Args...>
    {
        static void Dump(std::ostream& out)
        {
            out << TypeDesc< typename std::decay<P>::type >::Name();
            PrintDesc<Args...>::Dump(out);
        }

        static void Dump(std::ostream& out, const std::vector<std::string>& parmDescs, size_t i = 0)
        {
            // Did you specify all parameters?
            assert(parmDescs.size() > i);

            out << Style::Parameter()
                << TypeDesc< typename std::decay<P>::type >::Name()
                << reset
                << " "
                << parmDescs[i];

            if (i != parmDescs.size() - 1)
            {
                out << ", ";
            }

            PrintDesc<Args...>::Dump(out, parmDescs, i + 1);
        }
    };

    template <>
    struct PrintDesc<>
    {
        static void Dump(std::ostream& /*out*/) {}
        static void Dump(std::ostream& out, const std::vector<std::string>& parmDescs, size_t i = 0) {}
    };

    // *******************************************

    template <typename F, typename ... Args>
    class VariadicFunctionCommand : public Command
    {
    public:
        static constexpr size_t INVALID_INDEX = std::numeric_limits<size_t>::max();

        // disable value semantics
        VariadicFunctionCommand(const VariadicFunctionCommand&) = delete;
        VariadicFunctionCommand& operator = (const VariadicFunctionCommand&) = delete;

        VariadicFunctionCommand(const std::string& _name,
                                F func,
                                CleanupFn cleanupFunc,
                                std::string desc,
                                std::vector<std::string> parDesc)
            : Command(_name, std::move(desc))
            , m_commandFunc(std::move(func))
            , m_cleanupFunc(std::move(cleanupFunc))
            , parameterDesc(std::move(parDesc))
        {
        }

        void Cleanup() override
        {
            m_cleanupFunc();
        }

        ValidationResult Validate(const std::vector<std::string>& cmdLine) override
        {
            if (!IsEnabled()) return ValidationResult::NoMatch;
            assert(!cmdLine.empty());
            if (Name() != cmdLine[0])
            {
                return ValidationResult::NoMatch;
            }

            const std::size_t paramSize = sizeof...(Args);
            if (cmdLine.size() != paramSize + 1)
            {
                return ValidationResult::Invalid;
            }

            return ValidationResult::Match;
        }

        void ResetAutoComplete() override
        {
            m_autoCompleteIndices = { 0 };
        }

        template <typename T, size_t N>
        std::vector<std::string> GetAutoCompleteForParam(size_t param)
        {
            if (param >= sizeof...(Args))
            {
                return {};
            }
        }

        AutoCompleter::Completions GetParamCompletion(const std::string& paramStr,
            const size_t param) override
        {   
            if (param == 0)
            {
                return Command::GetParamCompletion(paramStr, param);
            }

            // TODO: Is this always true?
            if constexpr (sizeof...(Args) > 0)
            {
                const size_t zeroIndexedParam = param - 1;
                AutoCompleter autoCompleter = ParamUtil<Args...>::CallWith<ParamAutoComplete>(zeroIndexedParam, paramStr);
                if (!autoCompleter.HasValues())
                {
                    return {};
                }
                auto autoCompleteIndex = m_autoCompleteIndices[zeroIndexedParam] % autoCompleter.Size();
                m_autoCompleteIndices[zeroIndexedParam] = autoCompleteIndex + 1;
                return autoCompleter.GetAutoCompletions(autoCompleteIndex, paramStr);
            }
            else
            {
                return {};
            }
        }

        // paramIndex of 0 means first param, not command name
        bool ValidateParam(const std::string& param, const size_t paramIndex) const override
        {
            // TODO: Hmmmm, maybe this can go away
            return paramIndex < GetParamCount() - 1;
            //AutoCompleter autoCompleter = ParamUtil<Args...>::CallWith<ParamAutoComplete>(paramIndex);
            //return autoCompleter.HasValues();
        }

        bool Exec(const std::vector<std::string>& cmds, CliSession& session) override
        {
            if (!IsEnabled()) return false;
            const std::size_t paramSize = sizeof...(Args);
            if (cmds.size() != paramSize + 1)
            {
                return false;
            }

            if (Name() == cmds[0])
            {
                bool success = false;
                try
                {
                    auto g = [&](auto ... pars){ m_commandFunc( session.OutStream(), pars... ); };
                    success = Select<Args...>::Exec(session.OutStream(), g, std::next(cmds.begin()), cmds.end(),
                        parameterDesc, 0);
                }
                catch (std::bad_cast&)
                {
                    return false;
                }

                if (success && HasChildren())
                {
                    session.Current(this);
                }
                return success;
            }
            return false;
        }

        void Help(std::ostream& out) const override
        {
            if (!IsEnabled()) return;
            out << Style::Command() << Name() << reset << " (";
            if (parameterDesc.empty())
                PrintDesc<Args...>::Dump(out);
            else
                PrintDesc<Args...>::Dump(out, parameterDesc);

            out << "):\t" << description << std::endl;
        }

        size_t GetParamCount() const override { return 1 + sizeof...(Args); }

    private:
        const F m_commandFunc;
        CleanupFn m_cleanupFunc;
        const std::vector<std::string> parameterDesc;

        std::array<size_t, sizeof...(Args)> m_autoCompleteIndices = { 0 };
    };


    template <typename F>
    class FreeformCommand : public Command
    {
    public:
        // disable value semantics
        FreeformCommand(const FreeformCommand&) = delete;
        FreeformCommand& operator = (const FreeformCommand&) = delete;

        FreeformCommand(
            const std::string& _name,
            F fun,
            std::string desc,
            std::vector<std::string> parDesc = {}
        )
            : Command(_name), func(std::move(fun)), description(std::move(desc)), parameterDesc(std::move(parDesc))
        {
        }

        ValidationResult Validate(const std::vector<std::string>& cmdLine) override
        {
            if (!IsEnabled()) return ValidationResult::NoMatch;
            
            assert(!cmdLine.empty());
            if (Name() != cmdLine[0])
            {
                return ValidationResult::NoMatch;
            }

            return ValidationResult::Match;
        }

        bool Exec(const std::vector< std::string >& cmdLine, CliSession& session) override
        {
            if (!IsEnabled()) return false;
            assert(!cmdLine.empty());
            if (Name() == cmdLine[0])
            {
                func(session.OutStream(), std::vector<std::string>(std::next(cmdLine.begin()), cmdLine.end()));
                return true;
            }
            return false;
        }
        void Help(std::ostream& out) const override
        {
            if (!IsEnabled()) return;
            out << "Command: " << Style::Command() << Name() << reset;
            if (parameterDesc.empty())
                PrintDesc<std::vector<std::string>>::Dump(out);
            else
                PrintDesc<std::vector<std::string>>::Dump(out, parameterDesc);
            //for (auto& s: parameterDesc)
            //    out << " <" << s << '>';
            out << "\n\t" << description << "\n";
        }

        size_t GetParamCount() const override { return std::numeric_limits<size_t>::max(); }
        bool ValidateParam(const std::string& param, const size_t paramIndex) const override
        {
            return true;
        }
    private:

        const F func;
        const std::string description;
        const std::vector<std::string> parameterDesc;
    };


    // ********************************************************************
    // Menu implementation
    template <typename F, typename R, typename ... Args>
    CmdHandler Command::Insert(const std::string& cmdName, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, Args...) const)
    {
        const bool hasDescription = parDesc.size() == 0 || parDesc.size() == sizeof...(Args);
        // Ensure this command cmdName has all parameters described
        assert(hasDescription);
        return Insert(std::make_unique<VariadicFunctionCommand<F, Args ...>>(cmdName, f, [](){}, help, parDesc));
    }

    template <typename F, typename R, typename ... Args>
    CmdHandler Command::Insert(const std::string& cmdName, const std::string& help, const std::vector<std::string>& parDesc, F& f, CleanupFn cleanupFunc, R(F::*)(std::ostream& out, Args...) const)
    {
        assert(parDesc.size() == 0 || parDesc.size() == sizeof...(Args));
        return Insert(std::make_unique<VariadicFunctionCommand<F, Args ...>>(cmdName, f, cleanupFunc, help, parDesc));
    }

    template <typename F, typename R>
    CmdHandler Command::Insert(const std::string& cmdName, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, const std::vector<std::string>& args) const)
    {
        return Insert(std::make_unique<FreeformCommand<F>>(cmdName, f, help, parDesc));
    }

    template <typename F, typename R>
    CmdHandler Command::Insert(const std::string& cmdName, const std::string& help, const std::vector<std::string>& parDesc, F& f, R(F::*)(std::ostream& out, std::vector<std::string> args) const)
    {
        return Insert(std::make_unique<FreeformCommand<F>>(cmdName, f, help, parDesc));
    }
} // namespace cli

#endif // CLI_CLI_H
