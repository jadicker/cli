/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016-2021 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#pragma once

#pragma warning(disable: 4100) // unreferenced formal parameter

#include <numeric>
#include <optional>
#include <string>
#include <sstream>

#include <cli/detail/split.h>
#include <mutex>
#include "../colorprofile.h"
#include "inputdevice.h"
#include "autocomplete.h"
#include "cli/TerminalAnimations.h"

class ConsoleTestRunner;
class TerminalTests;

namespace cli
{
namespace detail
{

enum class Symbol
{
    nothing,
    command,
    up,
    down,
    tab,
    eof
};

class NulStreambuf : public std::streambuf
{
    char                dummyBuffer[64];
protected:
    virtual int         overflow(int c)
    {
        setp(dummyBuffer, dummyBuffer + sizeof(dummyBuffer));
        return (c == traits_type::eof()) ? '\0' : c;
    }
};
class NulOStream : private NulStreambuf, public std::ostream
{
public:
    NulOStream() : std::ostream(this) {}
    NulStreambuf* rdbuf() { return this; }
};

class Terminal
{
    friend class ParamList;
    friend class TerminalTests;

public:
    explicit Terminal(std::ostream& _out)
		: out(&_out)
		, m_terminalWidth(120) // make an assumption for now
		, m_animatedTerminal(120, 3)
	{}

    Terminal(const Terminal& t)
		: Terminal(*t.out)
	{}

	Terminal& operator=(const Terminal& other)
	{
		Terminal newTerminal(other);
		
		return *this;
	}

	// Maybe not the best but quick and dirty way for both the input system to lock on ANY input
	// (some of which flows through weird places like error messages in cli/session code) to ensure
	// the animation system isn't running.
	std::mutex& GetTerminalMutex() { return m_userInputLock; }

    void ResetInputLine() { m_position = m_promptSize; }

    size_t GetTerminalWidth() const { return m_terminalWidth; }
    size_t GetLineCount() const { return m_nextLines.size() + 1; }
    size_t GetInputPosition() const { return m_position - m_promptSize; }

    void SetLine(const std::string& newLine);

    void BackUpToPosition(size_t newPosition);

    // Doesn't support going down
    void GoBackToPosition(size_t posX, size_t posY);

    void CompleteLine();

    void SetCompletions(size_t param, const std::vector<AutoCompletion>& completions, const std::string& cmdDesc);


    void InsertText(std::string str);

    void TrimEnd(size_t toPosition, bool moveBack = true);

    std::string GetLine() const { return m_currentLine; }

    std::pair<Symbol, std::string> Keypressed(std::pair<KeyType, char> k);

    // Returns the parameter index, 0 for the command name
    size_t GetParamIndex(const std::string&) const;

    void SetLineStart(size_t start);

    void TestFill2Lines();

    // Return new line, param index
    static std::pair<std::string, size_t> PrepareAutoCompletedLine(const std::string& line, size_t position);

    // Return new line, param index
    std::pair<std::string, size_t> GetAutoCompleteLine() const;

    struct ParamInfo
    {
        bool IsValid() const { return startPos == std::numeric_limits<size_t>::max(); }

        size_t startPos = std::numeric_limits<size_t>::max();
        size_t endPos = std::numeric_limits<size_t>::max();
        size_t index = std::numeric_limits<size_t>::max();
    };

    // If pos lands on whitespace, 
    static ParamInfo GetParamInfo(const std::string& line, const size_t pos);

private:
    // Move the cursor forward
    void Advance(size_t size);

    void Reverse(size_t size);

    void Up(size_t lines);

    void Down(size_t lines);

    // Wipes size characters ahead of current position and leaves the cursor/position be
    void ClearAhead(size_t size = std::numeric_limits<size_t>::max());

    void ClearBehind(size_t size);

    static std::optional<std::pair<size_t, size_t>> GetToken(const std::string& line, size_t position);

    // Returns start index and size of the token TODO: Return string_view
    std::optional<std::pair<size_t, size_t>> GetToken(size_t position)
    {
        return GetToken(m_currentLine, position);
    }

    void ClearAutoComplete();

    bool TryFinishAutoComplete();

    struct SavePosition final
    {
        explicit SavePosition(Terminal* terminal)
            : m_terminal(terminal)
            , m_position(terminal->m_position)
            , m_cursorY(terminal->m_cursorY)
        {}

        ~SavePosition()
        {
            m_terminal->GoBackToPosition(m_position, m_cursorY);
        }

        Terminal* m_terminal;
        size_t m_position;
        size_t m_cursorY;
    };

    void ClearNextLines();

    // Clears everything after current input
    void ClearToCurrent();

    void ClearCurrentLine();

    void CreateLines(size_t count);

    void AddLine(const std::string& line);

    void Reset();

	AnimatedTerminal m_animatedTerminal;

    std::string m_currentLine;

    // All remaining lines are temporary
    std::vector<std::string> m_nextLines;

    size_t m_autoCompleteStart = std::string::npos;
    size_t m_position = 0; // next writing position in currentLine
    size_t m_cursorY = 0; // 0: current line
    size_t m_promptSize = 0;
    size_t m_terminalWidth;
    std::ostream* out;
    

    // For testing, no actual output
    bool m_silent = false;

	std::mutex m_userInputLock;
};

class ParamList
{
public:
    using Params = std::vector<AutoCompletion>;

    ParamList(const Params& params) : m_params(params) {}

    // Returns lines printed
    size_t Print(Terminal& t, size_t paramStartPos, size_t index, size_t style);

private:
    Params m_params;
};

} // namespace detail
} // namespace cli
